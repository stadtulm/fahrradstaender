var toArrayBuffer = function (buf) {
        var ab = new ArrayBuffer(buf.length);
        var view = new Uint8Array(ab);
        for (var i = 0; i < buf.length; ++i) {
            view[i] = buf[i];
        }
        return ab;
    }
    
    var toHalf = function( slice ) {
            var int16View = new Int16Array(toArrayBuffer(slice));
            var supportArray = new Int32Array(3);
            supportArray[0] = int16View[0] & 0x7fff; // Non-sign bits
            supportArray[1] = int16View[0] & 0x8000; // Sign bit
            supportArray[2] = int16View[0] & 0x7c00; // Exponent
    
            supportArray[0] = supportArray[0] << 13; // Align mantissa on MSB
            supportArray[1] = supportArray[1] << 16; // Shift sign bit into position
    
            supportArray[0] += 0x38000000; // Adjust bias
    
            supportArray[0] = (supportArray[2] == 0 ? 0 : supportArray[0]); //Denormals-as-zero
            supportArray[0] = supportArray[0] | supportArray[1]; //Re-insert sign bit
    
            console.log("Int16val: " + buf2hex(int16View.buffer));
            console.log("Support Array: " + buf2hex(supportArray.buffer));
    
            var floatView = new Float32Array(supportArray.buffer);
            return floatView[0];
    }
    
//Der Variable buf wird der Wert von msg.payload_raw zugewiesen dieser beinhaltet den Eingangswert der Funktion und damit den
//Wert der aus vom TTN und vom Sensor gesendet wurde
    var buf = msg.payload_raw;
var fields = {};

//Fahrraderkennung
fields["Fahrradzahl"] = 0;
fields["Fehler_Analog1"] = 0;
fields["Fehler_Analog2"] = 0;
fields["Stellplatz1"] = 0;
fields["Stellplatz2"] = 0;


//Die Analogwerte werden ausgewertet, indem geprüft wird ob sie einen gewissen Grenzwert überschreiten
//Dabei werden keine absoluten Werte verwendet, sondern die Messwerte werden durch die Batteriespannung geteilt
//Damit fällt der Einfluss der Batteriespannung weg und es wird nur geprüft ob ein gewisser Faktor überschritten wird
//Der Faktor leitet sich aus dem Widerstandsverhältnis des verwendeten Spannungsteilers her (0,5 im ungedrückten Zustand), plus
//einer gewissen Sicherheit (0,1)
//Wird der Schwellenwert überschritten, dann wird die Variable Stellplatz1 oder 2 auf 1 gesetzt

//Analog 1 auswerten
if ((buf.readUInt16BE(4) / buf.readUInt16BE(1)) > 0.6){
    fields["Stellplatz2"] = 1;
}
//Analog 2 auswerten
if ((buf.readUInt16BE(7) / buf.readUInt16BE(1)) > 0.6){
    fields["Stellplatz1"] = 1;
}

//Wie in der Doku beschrieben wird der Analogwert bei einem Kabelbruch auf GND und damit auf 0 gezogen.
//Dadurch lassen sich Fehler erkennen 
//In der If-Abfrage wird dies geprüft

//Analogwert 1
if (buf.readUInt16BE(4) === 0){
    fields["Fehler_Analog2"] = 1;
}
//Analogwert 2
if (buf.readUInt16BE(7) === 0){
    fields["Fehler_Analog1"] = 1;
}

//Da eine einzige Variable für die Fahrradanzahl gefragt ist, müssen die Werte der einzelnen Boxen addiert werden
//Dafür werden globale context Variablen verwendet. In den anderen Flows wird mit einer Change Funktion der Wert Stellplatz
//in einer solchen Variable gespeichert, über global.get werden diese abgerufen.

fields["Fahrradzahl"] = fields["Stellplatz1"] + fields["Stellplatz2"] + global.get("Stellplatz21") + global.get("Stellplatz22") + global.get("Stellplatz31") + global.get("Stellplatz32") + global.get("Stellplatz41") + global.get("Stellplatz42");

fields["bat_vol"] = buf.readUInt16BE(1);
fields["time"] = new Date().getTime() * 1000 * 1000;
msg.payload = [fields,{"ID":"Fahrradständer_1","measuretime":"network"}];
return msg;
